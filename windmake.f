!-------------------------------------------------------------------------------
! Using the equations derived by Lester Machta in an unpublished manuscript 
! titled "A MathematicalVerification of Trajectory Methods" from 1958, a 
! sinusoidal variation of the south-north wind component is superimposed on a 
! constant west-east zonal current which is used to create a gridded 
! meteorological data file. This file can then be read by HYSPLIT to compute 
! trajectories. In addition, an analytic form of the trajectory equation using 
! the parameters for the sinusoidal wind field is solved to provide the “True 
! Trajectory” and which is written to an output file compatible with the HYSPLIT 
! trajectory plotting program. This program, in conjunction with the results 
! from HYSPLIT, can be used to explore the effects sparse grids in space or time 
! on the accuracy of trajectories integrated using gridded data versus the 
! analytic true solution to the trajectory which uses a continuous representation 
! of the wind field. Detailed instructions about the required inputs for this
! program are available at https://www.hysplit.com/utility/traj_true.html
!-------------------------------------------------------------------------------
! This code, WINDMAKE, is distributed under the GNU General Public 
! license https://www.gnu.org/licenses/gpl-3.0.en.html
!-------------------------------------------------------------------------------
! Use the following statements to compile the code with gfortran:
! OPT="-ffree-form -fconvert=big-endian -frecord-marker=4"
! gfortran -owindmake ${OPT} windmake.f 
!
! Note the program uses free form data entry so only use a decimal point for
! numeric entries when they are present in the default value prompt. Output
! times use the current year and month but always start at 00:00 on the first.
!  
! Hardwired output files generated by this program:
! windgrid.bin - HYSPLIT compatible gridded meteorological data file
! windtraj.txt - HYSPLIT formatted analytic true trajectory
! CONTROL      - HYSPLIT CONTROL file for the trajectory starting position
!-------------------------------------------------------------------------------
! Author: roland.draxler@meteozone.com
! 20 Mar 2023 - Initial version
!-------------------------------------------------------------------------------

PROGRAM windmake

  IMPLICIT none

  REAL    :: v            ! south to north wind speed (m/s)
  REAL    :: u =  1.0     ! constant zonal wind speed (m/s)  
  REAL    :: a =  2.0     ! amplitude maximum value of v component (m/s)
  REAL    :: l = 100000.0 ! wavelength (m)
  REAL    :: c = 0.0      ! speed of wave in x-direction (m/s)
  REAL    :: x            ! downwind distance (m)
  REAL    :: pi2          ! two times pi

  LOGICAL        :: ftest ! file exist test result
  INTEGER        :: nrec  ! record counter for data records
  INTEGER        :: krec  ! record counter for index records
  REAL           :: prec  ! precision of packed data array
  INTEGER        :: nexp  ! packing scaling exponent
  REAL           :: var1  ! value of real array at position (1,1)
  INTEGER        :: ksum  ! rotating checksum

  CHARACTER(256) :: mfile           ! meteorology output file name
  CHARACTER(256) :: tfile           ! trajectory output file name
  INTEGER        :: kunit = 30      ! trajectory unit
  INTEGER        :: kdur = 28       ! duration of meteorology (h)        
  INTEGER        :: delt = 3600     ! trajectory output interval (s)

  INTEGER :: i,j,k,lev
  INTEGER :: nxy,len,lenh
  INTEGER :: nx,ny        ! grid dimensions 
  INTEGER :: iunit = 10   ! meteorology unit
  REAL    :: dx = 5000.0  ! meteorology i,j index spacing (m)
  REAL    :: grids(12)    ! grid values for packed data 
  INTEGER :: dt = 3600    ! meteorology time period interval (s)
  REAL    :: clat,clon    ! center location of meteorology grid

  INTEGER, PARAMETER :: nz = 3
  REAL               :: plvl(nz)  ! pressure levels (hPa)
  REAL               :: zlvl(nz)  ! geopotential ht (m)

  INTEGER :: ifh = 0      ! forecast hour
  INTEGER :: gid = 99     ! grid identification

! variables for date and time functions
  INTEGER            :: yr,mo,da,hr,mn
  INTEGER            :: date_time(8)
  CHARACTER(12)      :: real_clock(3)

! important constants
  REAL               :: dpm                ! degrees per meter
  REAL, PARAMETER    :: pi     = 3.14159265358979
  REAL, PARAMETER    :: rearth = 6371.2    ! radius of earth in km

! meteorological data grids
  REAL, ALLOCATABLE  :: pp(:,:)   ! surface pressure (hPa)
  REAL, ALLOCATABLE  :: hh(:,:)   ! terrain height (m)     
  REAL, ALLOCATABLE  :: zz(:,:,:) ! geopotential height (m)
  REAL, ALLOCATABLE  :: tt(:,:,:) ! temperature (K)
  REAL, ALLOCATABLE  :: uu(:,:,:) ! u-wind component (m/s)
  REAL, ALLOCATABLE  :: vv(:,:,:) ! v-wind component (m/s)
  REAL, ALLOCATABLE  :: ww(:,:,:) ! vertical velocity (hPa/s)

  INTEGER                 :: n        ! position in the chk array
  INTEGER(4), ALLOCATABLE :: chk(:)   ! checksums 
  INTEGER(1), ALLOCATABLE :: npack(:) ! packed int*1 output array
  CHARACTER(50)           :: label    ! first 50 bytes

! maximum output data structure desired variables
  INTEGER, PARAMETER :: nsfc=2
  INTEGER, PARAMETER :: nlvl=5
  INTEGER            :: nrpt=nsfc+nz*nlvl
  CHARACTER(4)       :: vchar0(nsfc),vchar1(nlvl)  

! set output structure in ARL character format
  DATA vchar0 /'PRSS','SHGT'/
  DATA vchar1 /'HGTS','TEMP','UWND','VWND','WWND'/
  DATA plvl   /1000.0,  850.0,  700.0/
  DATA zlvl   / 111.0, 1457.0, 3012.0/
  DATA mfile  /'windgrid.bin'/
  DATA tfile  /'windtraj.txt'/ 

!------------------------------------------------
  INTERFACE
  SUBROUTINE MKGRID(nx,ny,gsize,clat,clon,grids)
  IMPLICIT none
  INTEGER, INTENT(IN) :: nx,ny        ! number of grid points
  REAL, INTENT(IN)    :: gsize        ! grid spacing in km
  REAL, INTENT(IN)    :: clat,clon    ! center of the output grid
  REAL, INTENT(OUT)   :: grids(12)    ! lat-lon input grid values
  END SUBROUTINE mkgrid

  SUBROUTINE WINDEX(iunit,krec,yr,mo,da,hr,mn,grids,nsfc,vchar0,nlvl,vchar1, &
                    chk,plvl,nx,ny,nz,lenh)              
  IMPLICIT none
  INTEGER,        INTENT(IN)    :: iunit            ! output unit number   
  INTEGER,        INTENT(IN)    :: krec             ! output record number
  INTEGER,        INTENT(IN)    :: yr,mo,da,hr,mn   ! valid time of index record
  REAL,           INTENT(IN)    :: grids(12)        ! grid definition array
  INTEGER,        INTENT(IN)    :: nsfc             ! number of surface variables
  CHARACTER(4),   INTENT(IN)    :: vchar0(:)        ! surface variable list
  INTEGER,        INTENT(IN)    :: nlvl             ! number of upper level variables
  CHARACTER(4),   INTENT(IN)    :: vchar1(:)        ! upper levels variable list
  INTEGER,        INTENT(IN)    :: chk(:)           ! rotating checksum  
  REAL,           INTENT(IN)    :: plvl(:)          ! pressure vertical coordinate
  INTEGER,        INTENT(IN)    :: nx,ny,nz         ! grid dimensions
  INTEGER,        INTENT(IN)    :: lenh             ! header length
  END SUBROUTINE windex

  SUBROUTINE REPACK(rvar,npack,prec,nexp,var1,ksum)
  IMPLICIT none
  REAL,       INTENT(IN)  :: rvar(:,:)   ! data array to be packed
  INTEGER(1), INTENT(OUT) :: npack(:)    ! packed int*1 output array
  REAL,       INTENT(OUT) :: prec        ! precision of packed data array
  INTEGER,    INTENT(OUT) :: nexp        ! packing scaling exponent
  REAL,       INTENT(OUT) :: var1        ! value of real array at position (1,1)
  INTEGER,    INTENT(OUT) :: ksum        ! rotating checksum
  END SUBROUTINE repack
  END INTERFACE
!------------------------------------------------

  pi2=2.0*pi
  dpm=360.0/(pi2*rearth*1000.0) ! degrees lat-lon per meter

! default year and month to current date at midnight on the first
  CALL DATE_AND_TIME(real_clock(1),real_clock(2),real_clock(3),date_time)
  READ(real_clock(1),'(I4,2I2)')yr,mo,da   
  da=1 
  hr=0
  mn=0
  yr=yr-2000

! define the meteorological data
  CALL DATSET(a,u,c,l)

! compute the analytic trajectory
  CALL TRJCAL(kunit,yr,mo,kdur,delt,a,u,c,l,zlvl(2),plvl(2),tfile,mfile)

! define the output grid for the analytic meteorology field
  WRITE(*,*)' '
  x=2.0  
  WRITE(*,*)'Enter the extent of the meteorological grid (number of wavelengths)?',x
  READ (*,*) x
  WRITE(*,*)'Resulting in a grid of (km) =',(x*l)/1000.0
  dx=dx/1000.0
  WRITE(*,*)'Enter the distance between grid points (km)?',dx
  READ (*,*) dx
  dx=dx*1000.0   ! internal units meters
  nx=x*l/dx   
  ny=nx
  WRITE(*,*)'Resulting in the number of grid points =',nx
  dt=dt/60
  WRITE(*,*)'Enter the output time interval between successive grids (min)?',dt
  READ (*,*) dt
  dt=dt*60       ! internal units seconds

! determine the output file structure
  lenh=108+8*(1+nsfc+nz*(1+nlvl))

! check to insure the output record length is sufficient
  nxy=nx*ny   
  IF(lenh.GT.nxy)THEN
     WRITE(*,'(A)')'Output grid size too small to save index record data!'
     WRITE(*,'(A,I3)')'Reset to size: ',NINT(SQRT(FLOAT(lenh)))+1
     nx=NINT(SQRT(FLOAT(lenh)))+1
     ny=nx
     nxy=nx*ny   
  END IF

! allocate grids for meteorological variables
  len=nxy+50   
  ALLOCATE (npack(nxy))   
  ALLOCATE(pp(nx,ny),hh(nx,ny))
  ALLOCATE(zz(nx,ny,nz),tt(nx,ny,nz),            &
           uu(nx,ny,nz),vv(nx,ny,nz),ww(nx,ny,nz))
  ALLOCATE(chk(nrpt))

! the grid is defined such that lon=0 at i=2 and lat=0 at j=(ny+1)/2 and
! where clat and clon define the grid center position, which for longitude
! is always one grid point less than the half distance because i=2 at lon=0
  clat=0.0
  clon=dpm*dx*((nx+1.0)/2.0-1.0)

! define the grid structure array gsize for packed data
  CALL MKGRID(nx,ny,(dx/1000.0),clat,clon,grids)

! if the output file exists, delete first to avoid not overwriting all
! existing data if the new file contents are less than the existing file
  INQUIRE(FILE=mfile,EXIST=ftest)
  IF(ftest)THEN
     OPEN(iunit,FILE=mfile)
     CLOSE(iunit,STATUS='DELETE')
  END IF
  OPEN(iunit,FILE=mfile,RECL=len,ACCESS='DIRECT',FORM='UNFORMATTED')

! except for the u and v wind components, which use the formula below,
! populate grids with constant fields for 1000, 850, 700 hPa levels
  ww=0.0
  hh=0.0  
  pp=1013.25
  zz(:,:,1)=zlvl(1)
  tt(:,:,1)=287.5
  uu(:,:,1)=u     

  zz(:,:,2)=zlvl(2) 
  tt(:,:,2)=278.787
  uu(:,:,2)=u       

  zz(:,:,3)=zlvl(3)  
  tt(:,:,3)=268.65  
  uu(:,:,3)=u       

  nrec=0  ! intialize output file record counter

  WRITE(*,*)' '
  DO k = 0,(kdur*3600),dt
     da = k/86400+1
     hr = k/3600
     mn = (k-hr*3600)/60
     hr = MOD(hr,24)
     IF(k.EQ.0)WRITE(*,*)'Started writing: ',yr,mo,da,hr,mn

!    define the v-component of the wind field and at i=2 x=0
!    using Equation 39 from Machta (1958)
     DO j = 1,ny  
        DO i = 1,nx  
           x = (i-2)*dx 
           vv(i,j,:) = a*SIN(pi2*(x-c*k)/l)
        END DO
     END DO

!    pack the surface data into one-byte integers and output to file
     n=0         ! reset the checksum pointer each time period
     nrec=nrec+1 ! set pointer to index record for this time period
     krec=nrec   ! save the number to use at the end of the time period

!    write surface variables (only one, loop not required)
     lev=0
     n=n+1
     CALL REPACK(pp,npack,prec,nexp,var1,chk(n))
     WRITE(label,'(7I2,A4,I4,2E14.7)')yr,mo,da,hr,ifh,lev,gid,vchar0(1),nexp,prec,var1 
     nrec=nrec+1     
     WRITE(iunit,REC=nrec)label,npack 

     n=n+1
     CALL REPACK(hh,npack,prec,nexp,var1,chk(n))
     WRITE(label,'(7I2,A4,I4,2E14.7)')yr,mo,da,hr,ifh,lev,gid,vchar0(2),nexp,prec,var1 
     nrec=nrec+1     
     WRITE(iunit,REC=nrec)label,npack 

!    write upper level variables
     DO lev=1,nz  
        n=n+1
        CALL REPACK(zz(:,:,lev),npack,prec,nexp,var1,chk(n)) ! height
        WRITE(label,'(7I2,A4,I4,2E14.7)')yr,mo,da,hr,ifh,lev,gid,vchar1(1),nexp,prec,var1 
        nrec=nrec+1     
        WRITE(iunit,REC=nrec)label,npack 

        n=n+1
        CALL REPACK(tt(:,:,lev),npack,prec,nexp,var1,chk(n)) ! temperature
        WRITE(label,'(7I2,A4,I4,2E14.7)')yr,mo,da,hr,ifh,lev,gid,vchar1(2),nexp,prec,var1 
        nrec=nrec+1     
        WRITE(iunit,REC=nrec)label,npack 

        n=n+1
        CALL REPACK(uu(:,:,lev),npack,prec,nexp,var1,chk(n)) ! u-wind component
        WRITE(label,'(7I2,A4,I4,2E14.7)')yr,mo,da,hr,ifh,lev,gid,vchar1(3),nexp,prec,var1 
        nrec=nrec+1     
        WRITE(iunit,REC=nrec)label,npack 

        n=n+1
        CALL REPACK(vv(:,:,lev),npack,prec,nexp,var1,chk(n)) ! v-wind component
        WRITE(label,'(7I2,A4,I4,2E14.7)')yr,mo,da,hr,ifh,lev,gid,vchar1(4),nexp,prec,var1 
        nrec=nrec+1     
        WRITE(iunit,REC=nrec)label,npack 

        n=n+1
        CALL REPACK(ww(:,:,lev),npack,prec,nexp,var1,chk(n)) ! w-vertical velocity
        WRITE(label,'(7I2,A4,I4,2E14.7)')yr,mo,da,hr,ifh,lev,gid,vchar1(5),nexp,prec,var1 
        nrec=nrec+1     
        WRITE(iunit,REC=nrec)label,npack 
     END DO

!    the index record at the beginning of each time period cannot be written until
!    all the data records have been processed
     CALL WINDEX(iunit,krec,yr,mo,da,hr,mn,grids,nsfc,vchar0,nlvl,vchar1,  &
                 chk,plvl,nx,ny,nz,lenh)              
  END DO
  CLOSE (iunit)
  WRITE(*,*)'Compete writing: ',yr,mo,da,hr,mn
  WRITE(*,*)'to HYSPLIT formatted meteorological data file: ',TRIM(mfile)

END PROGRAM windmake

!-------------------------------------------------------------------------------
! sets the values for the output grid

SUBROUTINE MKGRID(nx,ny,gsize,clat,clon,grids)  

  IMPLICIT none

  INTEGER, INTENT(IN) :: nx,ny        ! number of grid points
  REAL, INTENT(IN)    :: gsize        ! grid spacing in km
  REAL, INTENT(IN)    :: clat,clon    ! center of the output grid
  REAL, INTENT(OUT)   :: grids(12)    ! lat-lon input grid values

  grids(1)=0.0             ! pole lat
  grids(2)=clon            ! pole lon 
  grids(3)=clat            ! reference lat
  grids(4)=clon            ! reference lon
  grids(5)=gsize           ! delta=x grid size in km
  grids(6)=0.0             ! grid orientation
  grids(7)=0.0             ! tangent latitude
  grids(8)=2.0             ! sync point x for lon=0
  grids(9)=(ny+1.0)/2.0    ! sync point y for lat=0
  grids(10)=0.0            ! sync point latitude
  grids(11)=0.0            ! sync point longitude
  grids(12)=0.0            ! variable reserved for future use

END SUBROUTINE mkgrid

!-------------------------------------------------------------------------------
! writes the header contents of the index record, which is always the first 
! record for a time period, which preceeds all the data records for that time

SUBROUTINE WINDEX(iunit,krec,yr,mo,da,hr,mn,grids,nsfc,vchar0,nlvl,vchar1, & 
                  chk,plvl,nx,ny,nz,lenh)              

  IMPLICIT none

  INTEGER,        INTENT(IN)    :: iunit            ! output unit number   
  INTEGER,        INTENT(IN)    :: krec             ! output record number
  INTEGER,        INTENT(IN)    :: yr,mo,da,hr,mn   ! valid time of index record
  REAL,           INTENT(IN)    :: grids(12)        ! grid definition array
  INTEGER,        INTENT(IN)    :: nsfc             ! number of surface variables
  CHARACTER(4),   INTENT(IN)    :: vchar0(:)        ! surface variable list
  INTEGER,        INTENT(IN)    :: nlvl             ! number of upper level variables
  CHARACTER(4),   INTENT(IN)    :: vchar1(:)        ! upper levels variable list
  INTEGER,        INTENT(IN)    :: chk(:)           ! rotating checksum  
  REAL,           INTENT(IN)    :: plvl(:)          ! pressure vertical coordinate
  INTEGER,        INTENT(IN)    :: nx,ny,nz         ! grid dimensions
  INTEGER,        INTENT(IN)    :: lenh             ! header length

  INTEGER         :: ksys=2     ! 1:sigma 2:pressure 3:z-terrain 4:hybrid
  CHARACTER(50)   :: label      ! first 50 bytes
  CHARACTER(5000) :: header     ! header portion of index

  INTEGER         :: i,j,k,m    ! temporary indicies
  INTEGER         :: lev = 0    ! level index (0,1,2,3,...) where 0=sfc
  INTEGER         :: ifh = 0    ! forecast hour
  INTEGER         :: gid = 99   ! grid identification
  INTEGER         :: icx = 0    ! extended forecast hour

  m=0  ! initialize checksum index

! fill in the first 50-byte label information  
  WRITE(label,'(7I2,A4,I4,2E14.7)')yr,mo,da,hr,ifh,lev,gid,'INDX',0,0.0,0.0  

! fill the header record with the grid information
  WRITE(header(1:108),'(A4,I3,I2,12F7.2,3I3,I2,I4)') 'VSIN',icx,mn,grids,nx,ny,(nz+1),ksys,lenh

! fill the header with the surface variables
  i=109
  WRITE(header(i:i+7),'(F6.1,I2)') 0.0,nsfc      
  i=i+8       
  DO j=1,nsfc
     m=m+1
     WRITE(header(i:i+7),'(A4,I3)') vchar0(j),chk(m)
     i=i+8    
  END DO

! fill the header with the upper level variables
  DO k=1,nz
     WRITE(header(i:i+7),'(F6.1,I2)') plvl(k),nlvl 
     i=i+8       
     DO j=1,nlvl       
        m=m+1
        WRITE(header(i:i+7),'(A4,I3)') vchar1(j),chk(m)   
        i=i+8      
     END DO
  END DO

! write the standard portion of the index record and the extended header
  WRITE(iunit,REC=krec)label,header(1:lenh)

END SUBROUTINE windex

!-------------------------------------------------------------------------------
! packs a two dimensional real*4 array into a one dimensional integer*1 array
! using the differences between succesive elements

SUBROUTINE REPACK(RVAR,KPACK,PREC,NEXP,VAR1,KSUM)

  IMPLICIT none  

  REAL,       INTENT(IN)  :: RVAR(:,:)   ! data array to be packed  
  INTEGER(1), INTENT(OUT) :: KPACK(:)    ! packed int*1 output array
  REAL,       INTENT(OUT) :: PREC        ! precision of packed data array
  INTEGER,    INTENT(OUT) :: NEXP        ! packing scaling exponent
  REAL,       INTENT(OUT) :: VAR1        ! value of real array at position (1,1)
  INTEGER,    INTENT(OUT) :: KSUM        ! rotating checksum

  INTEGER     :: I,J,K,NX,NY,IVAL
  REAL        :: SEXP,RMAX,ROLD,RCOL

  NX=SIZE(rvar,1)
  NY=SIZE(rvar,2)
  VAR1=RVAR(1,1)
  ROLD=VAR1
  RMAX=0.0

! find the maximum difference between adjacent elements
  DO J=1,NY
     DO I=1,NX
!       compute max difference between elements along row
        RMAX=MAX( ABS(RVAR(I,J)-ROLD),RMAX )
        ROLD=RVAR(I,J)
     END DO
!    row element 1 difference always from previous row
     ROLD=RVAR(1,J)
  END DO

! compute the required scaling exponent
  SEXP=0.0
  IF(RMAX.NE.0.0) SEXP=LOG(RMAX)/LOG(2.)
  NEXP=INT(SEXP)  

! positive or whole number scaling round up for lower precision
  IF(SEXP.GE.0.0.OR.MOD(SEXP,1.0).EQ.0.0)NEXP=NEXP+1

! precision range is -127 to 127 or 254
  PREC=(2.0**NEXP)/254.0
  SEXP=2.0**(7-NEXP)

  K=0
  KSUM=0
  RCOL=VAR1   ! set column1 value
! pack the array from low to high
  DO J=1,NY
     ROLD=RCOL
     DO I=1,NX
        K=K+1
        IVAL=INT((RVAR(I,J)-ROLD)*SEXP+127.5) ! packed integer at element
        ROLD=FLOAT(IVAL-127)/SEXP+ROLD        ! previous element unpacked
        IF(I.EQ.1)RCOL=ROLD                   ! save the 1st col element for next row
        KPACK(K)=INT(IVAL,kind=1)             ! convert 4-byte int to 1-byte int

        KSUM=KSUM+IVAL                        ! accumulate rotating checksum
        IF(KSUM.GE.256)KSUM=KSUM-255          ! when carries over the 8th bit then reset
     END DO
  END DO

END SUBROUTINE repack

!-------------------------------------------------------------------------------
! Configure the trajectory output file

SUBROUTINE TRJSET(kunit,yr,mo,da,hr,olat,olon,olvl,tfile) 

  IMPLICIT NONE

  INTEGER, INTENT(IN) :: kunit          ! output file unit number 
  INTEGER, INTENT(IN) :: yr,mo,da,hr    ! date
  REAL,    INTENT(IN) :: olat           ! source latitude
  REAL,    INTENT(IN) :: olon           ! source longitude
  REAL,    INTENT(IN) :: olvl           ! source height
  CHARACTER(256), INTENT(IN) :: tfile   ! output file name 
  
  CHARACTER(8)       :: dirctn, motion, metout
  INTEGER, PARAMETER :: tfmt = 1    ! trajectory file format
  INTEGER, PARAMETER :: kmet = 1    ! number of meteo files
  INTEGER, PARAMETER :: nloc = 1    ! number of start locations
  INTEGER, PARAMETER :: ndia = 1    ! number of output diagnostics
  INTEGER, PARAMETER :: mn   = 0    ! minutes always zero
  
  DATA dirctn /'FORWARD'/
  DATA motion /'OMEGA'/  
  DATA metout /'PRESSURE'/
  
  OPEN(kunit,FILE=tfile)
  WRITE(kunit,'(2I6)')            kmet,tfmt
  WRITE(kunit,'(A8,5I6)')        'VSIN',yr,mo,da,hr,mn
  WRITE(kunit,'(I6,2(1X,A8))')    nloc,dirctn,motion
  WRITE(kunit,'(4I6,2F9.3,F8.1)') yr,mo,da,hr,olat,olon,olvl
  WRITE(kunit,'(I6,10(1X,A8))')   ndia,metout

END SUBROUTINE trjset

!-------------------------------------------------------------------------------
! Output trajectory endpoints to disk

SUBROUTINE TRJDSK(kunit,yr,mo,da,hr,mn,age,tlat,tlon,thgt,tmet)

  IMPLICIT NONE

  INTEGER,  INTENT(IN) :: kunit           ! output file unit number       
  INTEGER,  INTENT(IN) :: yr,mo,da,hr,mn  ! trajectory date and time
  REAL,     INTENT(IN) :: age             ! trajectory age from start
  REAL,     INTENT(IN) :: tlat,tlon       ! trajectory position   
  REAL,     INTENT(IN) :: thgt            ! trajectory height AGL
  REAL,     INTENT(IN) :: tmet            ! trajectory diagnostic variable

  WRITE(kunit,'(8I6,F8.1,2F9.3,11(1X,F8.1))') &   
        1,1,yr,mo,da,hr,mn,0,age,tlat,tlon,thgt,tmet 

END SUBROUTINE trjdsk

!-------------------------------------------------------------------------------
! Configure the HYSPLIT CONTROL file   

SUBROUTINE CNTSET(junit,olat,olon,olvl,kdur,mfile) 

  IMPLICIT NONE

  INTEGER, INTENT(IN) :: junit          ! output file unit number 
  REAL,    INTENT(IN) :: olat,olon,olvl ! source 
  INTEGER, INTENT(IN) :: kdur           ! duration (hrs)
  CHARACTER(256), INTENT(IN) :: mfile   ! meteorology name 

  OPEN(junit,FILE='CONTROL')              
  WRITE(junit,'(A)')              '00 00 00 00'
  WRITE(junit,'(A)')              '1'
  WRITE(junit,'(F3.1,F8.4,F7.1)')  olat,olon,olvl    
  WRITE(junit,'(I2)')              kdur
  WRITE(junit,'(A)')              '0'
  WRITE(junit,'(A)')              '10000.0'
  WRITE(junit,'(A)')              '1'
  WRITE(junit,'(A)')              './'
  WRITE(junit,'(A)')               TRIM(mfile)            
  WRITE(junit,'(A)')              './'
  WRITE(junit,'(A)')              'hysptraj.txt'   
  CLOSE(junit)

END SUBROUTINE cntset 

!-------------------------------------------------------------------------------
! Calculate the analytic trajectory solution

SUBROUTINE TRJCAL(kunit,yr,mo,kdur,delt,a,u,c,l,zlvl,plvl,tfile,mfile)

  IMPLICIT none
  INTEGER, INTENT(IN)    :: kunit
  INTEGER, INTENT(IN)    :: yr,mo
  INTEGER, INTENT(INOUT) :: kdur         ! total trajectory duration (hrs)
  INTEGER, INTENT(INOUT) :: delt         ! trajectory output interval (sec)
  REAL,    INTENT(IN)    :: a            ! amplitude  (m/s)
  REAL,    INTENT(IN)    :: u            ! zonal wind (m/s)
  REAL,    INTENT(IN)    :: c            ! wave speed (m/s)
  REAL,    INTENT(IN)    :: l            ! wave length (m)  
  REAL,    INTENT(IN)    :: zlvl         ! trajectory height (m)
  REAL,    INTENT(IN)    :: plvl         ! trajectory pressure (hPa)
  CHARACTER(256), INTENT(IN) :: tfile    ! output file name 
  CHARACTER(256), INTENT(IN) :: mfile    ! output file name 

  INTEGER  :: t         ! elapsed time (sec)
  INTEGER  :: da,hr,mn  ! computed time
  REAL(8)  :: pi2       ! twice pi
  REAL(8)  :: x,y       ! trajectory position (m)
  REAL(8)  :: cp        ! zonal wind - wave speed (m/s)
  REAL(4)  :: tlat,tlon ! converted trajectory position
  REAL(4)  :: olat,olon ! trajectory starting position
  REAL(8)  :: x0,y0     ! starting position (m)

! important constants
  REAL(8)               :: dpm                ! degrees per meter
  REAL(8), PARAMETER    :: rearth = 6371.2    ! radius of earth in km
  REAL(8), PARAMETER    :: pi     = 3.14159265358979
  REAL(8), PARAMETER    :: zero   = 0.00000001

  pi2=2.0*pi
  dpm=360.0/(pi2*rearth*1000.0) ! degrees lat-lon per meter

  WRITE(*,*)' '
  WRITE(*,*)'Enter the duration of the trajectory calculation (h)?',kdur
  READ (*,*) kdur
  delt=delt/60
  WRITE(*,*)'Enter the trajectory endpoint output interval (min)?',delt
  READ (*,*) delt
  delt=delt*60
  olon=90.0
  WRITE(*,*)'Enter the trajectory starting position within the sine wave (deg)?',olon
  READ(*,*) olon
  olon=MOD(ABS(olon),360.0)
  
! Using the relation x/l = olon/360.0
  x0=olon*l/360.0
  y0=0.0
! convert to positive degrees longitude from 0.0
  olon=x0*dpm
  olat=0.0
  WRITE(*,*)'Starting lat,lon: ',olat,olon

! open the calculated trajectory output file 
  CALL TRJSET(kunit,yr,mo,da,0,olat,olon,zlvl,tfile) 

  cp=u-c
! divide by zero not permitted in solution
  IF(ABS(cp).LT.zero) cp=SIGN(zero,cp) 

  DO t = 0,(kdur*3600),delt
!    analytic trajectory solution for previously defined windfield
!    all trajectory calculations are with respect to clat=0 clon=0 
!    and where x,y is the distance from the origin
!    Equation 40 from Machta (1958)        
     x = u*t+x0
     y = (a*l)*(COS(pi2*x0/l)-COS(pi2*(x0+cp*t)/l))/(pi2*cp)+y0 

!    convert distance to lat,lon units (assume conformal map)
     tlat=y*dpm
     tlon=x*dpm
     da = t/86400+1
     hr = t/3600
     mn = (t-hr*3600)/60
     hr = MOD(hr,24)
     CALL TRJDSK(kunit,yr,mo,da,hr,mn,(t/3600.0),tlat,tlon,zlvl,plvl)
  END DO
  CLOSE(kunit)
  WRITE(*,*)'Analytic trajectory output file created: ',TRIM(tfile)

! create the HYSPLIT control file
  CALL CNTSET(kunit,olat,olon,zlvl,kdur,mfile) 
  WRITE(*,*)'HYSPLIT CONTROL file created for starting location: ',olon

END SUBROUTINE trjcal


!-------------------------------------------------------------------------------
! Define the wind field for the analytic trajectory solution

SUBROUTINE DATSET(a,u,c,l)

  IMPLICIT none
  REAL, INTENT(INOUT) :: a    ! amplitude  (m/s)
  REAL, INTENT(INOUT) :: u    ! zonal wind (m/s)
  REAL, INTENT(INOUT) :: c    ! wave speed (m/s)
  REAL, INTENT(INOUT) :: l    ! wave length (m)  

  WRITE(*,*)' '
  WRITE(*,*)'Input the values required to define a wind field with a'
  WRITE(*,*)'sinusoidal variation of the south-north (V) wind component'
  WRITE(*,*)'which is superimposed on a west-east (U) zonal current.'
  WRITE(*,*)' '
  WRITE(*,*)'Enter the constant zonal U-component wind speed (m/s)?',u
  READ (*,*) u
  WRITE(*,*)'Enter the maximum amplitude of the V-component wind speed (m/s)?',a
  READ (*,*) a
  l=l/1000.0
  WRITE(*,*)'Enter the wavelength of the sinusoidal variation (km)?',l
  READ (*,*) l
  l=l*1000.0      ! internal units m not km
  c=c*3.6
  WRITE(*,*)'Enter the west to east speed of the wave (km/h)?',c
  READ (*,*) c
  c=c/3.6         ! internal units m/s not km/h

END SUBROUTINE datset  
